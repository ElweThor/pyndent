
 ___META_SYNTAX:_PRE-PROCESSOR_DIRECTIVES___
 
 Pyndent code syntax is 100% pure python, as it must be. The meta-syntax, used by pyndent pre-processor to rebuild the (python) code indentation, uses a couple of "code-block delimiters" (by default C-like ones: "{" and "}", but they can be customized) and a few meta-statement (AKA pre-processor directives):
 
 #delim <start_delimiter> <stop_delimiter>
 
 where <start_delimiter> and <stop_delimiter> can be single characters (usually in pairs: "{" "}", "<" ">", "[" "]", but they can be litterally everything, as far as you follow pyndent meta-syntax: "/" "\", "->" "<-", etc.) or even single words (e.g. "begin" "end", "block_start" "block_end", "apples" "bananas").
 The only unusable character is "#" as it's reserved for pre-processor directives, and will be used to comment out the delimiters in source.py output files (which means "##" can't be a valid delimiter)
 You need to use #delim directive as soon as you like/need to use non-standard delimiters, as pyndent needs to know how you (custom) delimited your code blocks, to re-indent them.
 Like all pyndent pre-processor directives, #delim must appear at meta-source top, for it to be used: if read during the meta-source scan it will be taken as normal python comment and skipped (writted out but not interpreted as a directive).


 ___DIRECTIVES_EXAMPLES___
 
 #delim example #1:
 
#delim begin end
def example():
begin
    if True:
    begin
        print("nested")
    end
end
 
 #delim example #2:
 
#delim < >
def example():
<
    if True:
    <
        print("nested")
    >
>


 ___COMMAND_SWITCHES___
 
 By default, pyindent reads a meta-source (<filename>.pyn) and writes a full python source to <stdout>, nothing else: it only rebuilds indentation from scratch.
 As it can be customized and asked for different tasks, you can use the following switches too:

 -o --outfile: asks pyndent to write the output to a <filename>.py instead of <stdout>. <filename> is optional: if not given, the meta-source one is used

	pyndent -o source.py metasource.pyn	-> will read metasource.pyn and write source.py file, instead of just output the processed results to <stdout>
	pyndent metasource.pyn -o source.py	-> the same, with more "natural" syntax: input first, then output file as last
	pyndent -o metasource.pyn				-> will read metasource.pyn and write metasource.py file: <metasource> filename is taken from metasource.pyn input
	pyndent metasource.pyn -o				-> the same, even if less intuitive but it works too
 
 -e --execute: tells pyndent to launch python, passing it the produced python code file to process, if the pre-processing ended correctly (RC = 0). By default, the code is written to <stdout>, so it's read from <stdin> by python (unless -o or -x are used)
 
	pyndent -e metasource.pyn	-> will produce a python source to <stdout>, then launch python to execute it

 -x --output-execute: combo switch implying -e and -o
 
	pyndent -x metasource.pyn			-> will be internally translated into pyndent -e -o metasource.pyn, resulting in metasource.py file on disk, then python interpreter executing it
	pyndent -x source.py metasource.pyn	-> will be internally translated into pyndent -e -o source.py metasource.pyn, resulting in source.py file on disk, then python interpreter executing it
 
 -s --strip: tells pyndent to strip the delimiters away from the final python code (AKA not write them out at all), producing 100% pure python source without the code-blocks delimiters commented out

	pyndent -s metasource.pyn	-> will write the resulting source.py without "#{" and "#}" (defaults)
	
 -r --restore: asks pyndent to reverse-process a python source.py into a pyndent metasource.pyn, restoring the code-block delimiters from commented ones, or even re-adding them if they've been --strip (in this case you need to give an inline #delim start_delimiter stop_delimiter directive too, if you want to override the defaults)
 
	pyndent -r source.py			-> will write metasource.pyn, assuming there are code-block delimiters, commented in the source.py code, wether or not they're default ones: delimiters will be read directly from the source and restored. If any delimiter will be found, pyndent re-process source.py by using "{" and "}" defaults like it found "#{" and "#}"
 	pyndent -r #delim < > source.py	-> the same, but pyndent assumes there are no pre-existing (commented) code-block delimiters to restore (or just skip existing ones, leaving them commented out): it will add the given delimiters instead

 -v --verbose --v2: if -o switch is given, -v asks pyndent to write the output to <stdout> also. If given twice (-v -v or --v2) it will write its own operations too, as comments, in <stdout> stream (e.g. "#pyndent: found #< custom code-block start delimiter -> replaced with begin")

	pyndent -v -o source.py metasource.pyn	-> will read metasource.pyn and write source.py file, but also output the processed results to <stdout>
	pyndent -v metasource.pyn -o source.py	-> the same, with more "natural" syntax
	pyndent -v -v -o source.py metasource.pyn	-> the same, but with more details


 ___OBSOLETES___
 
 -d --dryrun: asks pyndent to simulate the reindentation process, also doing all the needed checks, showing the results but not writing the output .py file
	pyndent -d metasource.pyn	-> will write the results to <stdout> but won't write to file

 no more needed as that's pyndent default behavior


 ___DOCUMENT_HISTORY___
 
 20250925 original
 20250925 fixed typos and examples added (Aria@DeepSeek)
